apiVersion: v1
kind: ConfigMap
metadata:
  name: gateway-synthetic-tests
  namespace: observability
data:
  gateway-api-test.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Trend } from 'k6/metrics';
    
    // Custom metrics
    const errorRate = new Rate('gateway_synthetic_error_rate');
    const responseTime = new Trend('gateway_synthetic_response_time');
    
    // Test configuration
    export const options = {
      stages: [
        { duration: '2m', target: 10 },   // Ramp up to 10 users
        { duration: '5m', target: 10 },   // Stay at 10 users
        { duration: '2m', target: 20 },  // Ramp up to 20 users
        { duration: '5m', target: 20 },  // Stay at 20 users
        { duration: '2m', target: 0 },    // Ramp down to 0 users
      ],
      thresholds: {
        'http_req_duration': ['p95<200'], // 95% of requests must complete below 200ms
        'http_req_failed': ['rate<0.1'],  // Error rate must be below 10%
        'gateway_synthetic_error_rate': ['rate<0.05'], // Custom error rate below 5%
        'gateway_synthetic_response_time': ['p95<150'], // Custom response time below 150ms
      },
    };
    
    // Test data
    const testInstruments = [
      'AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN',
      'META', 'NVDA', 'NFLX', 'ADBE', 'CRM'
    ];
    
    export default function () {
      // Test 1: Health check
      const healthResponse = http.get('http://gateway:8080/health');
      check(healthResponse, {
        'health check status is 200': (r) => r.status === 200,
        'health check response time < 100ms': (r) => r.timings.duration < 100,
        'health check contains service name': (r) => r.json('service') === 'gateway',
      });
      errorRate.add(healthResponse.status !== 200);
      responseTime.add(healthResponse.timings.duration);
      
      sleep(1);
      
      // Test 2: Get instrument data
      const instrument = testInstruments[Math.floor(Math.random() * testInstruments.length)];
      const instrumentResponse = http.get(`http://gateway:8080/api/v1/instruments/${instrument}`);
      check(instrumentResponse, {
        'instrument request status is 200': (r) => r.status === 200,
        'instrument response time < 200ms': (r) => r.timings.duration < 200,
        'instrument response has id': (r) => r.json('id') === instrument,
        'instrument response has data': (r) => r.json('data') !== undefined,
      });
      errorRate.add(instrumentResponse.status !== 200);
      responseTime.add(instrumentResponse.timings.duration);
      
      sleep(1);
      
      // Test 3: Process request
      const processPayload = {
        id: instrument,
        action: 'get_quote',
        timestamp: Date.now()
      };
      const processResponse = http.post(
        'http://gateway:8080/api/v1/process',
        JSON.stringify(processPayload),
        {
          headers: { 'Content-Type': 'application/json' },
        }
      );
      check(processResponse, {
        'process request status is 200': (r) => r.status === 200,
        'process response time < 300ms': (r) => r.timings.duration < 300,
        'process response has id': (r) => r.json('id') === instrument,
        'process response has data': (r) => r.json('data') !== undefined,
        'process response has external data': (r) => r.json('external') !== undefined,
      });
      errorRate.add(processResponse.status !== 200);
      responseTime.add(processResponse.timings.duration);
      
      sleep(2);
    }
    
    export function handleSummary(data) {
      return {
        'synthetic-test-results.json': JSON.stringify(data, null, 2),
      };
    }
  
  websocket-test.js: |
    import ws from 'k6/ws';
    import { check, sleep } from 'k6';
    import { Rate, Trend } from 'k6/metrics';
    
    // Custom metrics
    const connectionErrorRate = new Rate('websocket_connection_error_rate');
    const messageLatency = new Trend('websocket_message_latency');
    
    export const options = {
      stages: [
        { duration: '1m', target: 5 },   // Ramp up to 5 connections
        { duration: '3m', target: 5 },   // Stay at 5 connections
        { duration: '1m', target: 0 },    // Ramp down to 0 connections
      ],
      thresholds: {
        'websocket_connection_error_rate': ['rate<0.1'], // Connection error rate below 10%
        'websocket_message_latency': ['p95<100'], // Message latency below 100ms
      },
    };
    
    export default function () {
      const url = 'ws://gateway:8080/ws';
      const params = { tags: { name: 'WebSocket Test' } };
      
      ws.connect(url, params, function (socket) {
        socket.on('open', function () {
          console.log('WebSocket connection opened');
          
          // Send test message
          const message = {
            type: 'ping',
            timestamp: Date.now(),
            data: 'synthetic test message'
          };
          
          socket.send(JSON.stringify(message));
        });
        
        socket.on('message', function (data) {
          const message = JSON.parse(data);
          const latency = Date.now() - message.timestamp;
          
          check(message, {
            'message type is pong': (m) => m.type === 'pong',
            'message has timestamp': (m) => m.timestamp !== undefined,
            'message latency < 100ms': () => latency < 100,
          });
          
          messageLatency.add(latency);
          socket.close();
        });
        
        socket.on('close', function () {
          console.log('WebSocket connection closed');
        });
        
        socket.on('error', function (e) {
          console.log('WebSocket error:', e);
          connectionErrorRate.add(1);
        });
      });
      
      sleep(1);
    }
    
    export function handleSummary(data) {
      return {
        'websocket-test-results.json': JSON.stringify(data, null, 2),
      };
    }
  
  load-test.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Trend, Counter } from 'k6/metrics';
    
    // Custom metrics
    const errorRate = new Rate('load_test_error_rate');
    const responseTime = new Trend('load_test_response_time');
    const requestCount = new Counter('load_test_requests_total');
    
    export const options = {
      stages: [
        { duration: '1m', target: 50 },   // Ramp up to 50 users
        { duration: '3m', target: 50 },   // Stay at 50 users
        { duration: '1m', target: 100 },  // Ramp up to 100 users
        { duration: '3m', target: 100 },  // Stay at 100 users
        { duration: '1m', target: 0 },    // Ramp down to 0 users
      ],
      thresholds: {
        'http_req_duration': ['p95<500'], // 95% of requests must complete below 500ms
        'http_req_failed': ['rate<0.05'],  // Error rate must be below 5%
        'load_test_error_rate': ['rate<0.03'], // Custom error rate below 3%
        'load_test_response_time': ['p95<400'], // Custom response time below 400ms
      },
    };
    
    export default function () {
      // Load test endpoint
      const loadTestPayload = {
        num_requests: 10,
        delay_ms: 100
      };
      
      const response = http.post(
        'http://gateway:8080/api/v1/load-test',
        JSON.stringify(loadTestPayload),
        {
          headers: { 'Content-Type': 'application/json' },
        }
      );
      
      check(response, {
        'load test status is 200': (r) => r.status === 200,
        'load test response time < 500ms': (r) => r.timings.duration < 500,
        'load test has results': (r) => r.json('results') !== undefined,
        'load test has count': (r) => r.json('count') === 10,
      });
      
      errorRate.add(response.status !== 200);
      responseTime.add(response.timings.duration);
      requestCount.add(1);
      
      sleep(0.5);
    }
    
    export function handleSummary(data) {
      return {
        'load-test-results.json': JSON.stringify(data, null, 2),
      };
    }
